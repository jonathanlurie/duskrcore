{"version":3,"file":"duskrcore.js","sources":["../src/AdobeMetadata.js","../src/AdobeMetadataInterpolator.js","../src/index.js"],"sourcesContent":["import XmlParser from 'xml-js'\n\n// list of basic attributes to not interpolate\nconst UNSETTINGS = [\n  'Version',\n  'ProcessVersion'\n]\n\nclass AdobeMetadata {\n\n  /**\n   * Val is a string, but it can represent a number, a boolean or a string.\n   * This function converts val into the most appropriate type.\n   * @param  {string} val - a value\n   * @return {string|number|boolean}\n   */\n  static convertToRelevantType(val){\n    let cleanVal = val.trim()\n    // boolean: true\n    if(cleanVal === 'True' || cleanVal === 'true' || cleanVal === 'TRUE')\n      return true\n\n    // boolean: false\n    if(cleanVal === 'False' || cleanVal === 'false' || cleanVal === 'FALSE')\n      return false\n\n    // a number\n    if(parseFloat(cleanVal) !== NaN)\n      return parseFloat(cleanVal)\n\n    // a string\n    return cleanVal\n  }\n\n\n  static convertToString(val){\n    if(val === true)\n      return 'True'\n\n    if(val === false)\n      return 'False'\n\n    if(typeof val === 'number'){\n      // round to a precision that is unnecessary for most settings but that is\n      // relevant for the crop\n      let roundedVal = Math.round(val * 1000000) / 1000000\n      return roundedVal.toString()\n    }\n\n    return val.trim()\n  }\n\n\n  static validateCurveData(values){\n    if(values.length < 2)\n      throw new Error('Curve data must contain at least two points.')\n\n    if(! values.every(point => Array.isArray(point) && (point.length === 2) ) )\n      throw new Error('Each point provided to a curve must be arrays of size two.')\n\n    values.flat().forEach(val => {\n      if(isNaN(val))\n        throw new Error('All the curve data values must be numbers')\n\n      if(val < 0 || val > 255 )\n        throw new Error('All values must be in the range [0, 255]')\n    })\n\n    return true\n  }\n\n\n  static orderCurveData(values){\n    let orderedAlongX = values.sort((pointA, pointB) => pointA[0] - pointB[0] )\n    return orderedAlongX\n  }\n\n\n  /**\n   * Check is the curve has only the values [[0, 0], [255, 255]]\n   */\n  static isDefaultCurve(values){\n    try{\n      if(value.length === 2 &&\n         value[0][0] === 0 && value[0][1] === 0 &&\n         value[1][0] === 255 && value[1][1] === 255){\n        return true\n      }else{\n        return false\n      }\n    }catch(e){\n      return false\n    }\n  }\n\n  constructor(){\n    this._xmlPayload = null\n    this._objectRepresentation = null\n  }\n\n\n  setXmlPayload(xmlStr){\n    this._xmlPayload = xmlStr\n    let jsonPayload = XmlParser.xml2json(xmlStr, {compact: true})\n    this._objectRepresentation = JSON.parse(jsonPayload)\n  }\n\n\n  getXml(){\n    return XmlParser.json2xml(JSON.stringify(this._objectRepresentation), {compact: true, ignoreComment: true, spaces: 4})\n  }\n\n\n  _getBasicAttributesObject(){\n    return this._getDescriptionObject()['_attributes']\n  }\n\n\n  _getDescriptionObject(){\n    return this._objectRepresentation['x:xmpmeta']['rdf:RDF']['rdf:Description']\n  }\n\n\n  hasSettings(){\n    let ba = this._getBasicAttributesObject()\n    return ba['crs:HasSettings'] === 'True'\n  }\n\n\n  getRawFileName(){\n    let ba = this._getBasicAttributesObject()\n    return ba['crs:RawFileName']\n  }\n\n\n  setRawFileName(name){\n    let ba = this._getBasicAttributesObject()\n    ba['crs:RawFileName'] = name\n  }\n\n\n  getListOfSettingAttributes(){\n    let ba = this._getBasicAttributesObject()\n    let allNames = Object.keys(ba)\n      .filter(attrName => attrName.startsWith('crs:'))\n      .filter(attrName => {\n        let attrValue = ba[attrName]\n        return !isNaN(parseFloat(attrValue))\n      })\n      .map(attrName => attrName.split(':')[1])\n      .filter(attrName => !UNSETTINGS.includes(attrName))\n\n    return allNames\n  }\n\n\n  getSettingAttribute(attrName){\n    let ba = this._getBasicAttributesObject()\n    if(`crs:${attrName}` in ba){\n      return AdobeMetadata.convertToRelevantType(ba[`crs:${attrName}`])\n    }else{\n      return null\n    }\n  }\n\n\n  setSettingAttribute(attrName, value){\n    let ba = this._getBasicAttributesObject()\n    ba[`crs:${attrName}`] = AdobeMetadata.convertToString(value)\n  }\n\n\n  hasCrop(){\n    let ba = this._getBasicAttributesObject()\n    return this.getSettingAttribute('HasCrop')\n  }\n\n\n  enableCropping(){\n    let ba = this._getBasicAttributesObject()\n    if(!this.getSettingAttribute('HasCrop')){\n      this.setSettingAttribute('HasCrop', true) // This one was false\n      this.setSettingAttribute('CropTop', 0) // this one and the next where not existing\n      this.setSettingAttribute('CropLeft', 0)\n      this.setSettingAttribute('CropBottom', 1)\n      this.setSettingAttribute('CropRight', 1)\n      this.setSettingAttribute('CropAngle', 0)\n      this.setSettingAttribute('CropConstrainToWarp', 1)\n    }\n  }\n\n\n  // ToneCurvePV2012\n  getCurveTone(color=''){\n    let desc = this._getDescriptionObject()\n    let curveObjName = 'crs:ToneCurvePV2012'\n\n    if(color.toLowerCase() === 'red')\n      curveObjName += 'Red'\n    else if(color.toLowerCase() === 'green')\n      curveObjName += 'Green'\n    else if(color.toLowerCase() === 'blue')\n      curveObjName += 'Blue'\n\n    let curveObj = desc[curveObjName]['rdf:Seq']['rdf:li'] // this is an array\n    let curveData = curveObj.map(li => {\n      // for each li elem, there is a string with 2 numbers separated by a comma: \"128, 128\"\n      let text = li._text\n      let values = text.split(',').map(numStr => parseInt(numStr.trim()))\n      return values\n    })\n\n    return curveData\n  }\n\n\n  setCurveTone(values, color=''){\n    AdobeMetadata.validateCurveData(values) // possibly throw an exception\n\n    // perform a possibly unnecessary reordering or data\n    let orderedValues = AdobeMetadata.orderCurveData(values)\n\n    let desc = this._getDescriptionObject()\n    let curveObjName = 'crs:ToneCurvePV2012'\n\n    if(color.toLowerCase() === 'red')\n      curveObjName += 'Red'\n    else if(color.toLowerCase() === 'green')\n      curveObjName += 'Green'\n    else if(color.toLowerCase() === 'blue')\n      curveObjName += 'Blue'\n\n    // let curveObj = desc[curveObjName]['rdf:Seq']['rdf:li'] // this is an array\n    desc[curveObjName]['rdf:Seq']['rdf:li'] = orderedValues.map(point => {\n      return {\n        _text: point.join(', ')\n      }\n    })\n  }\n\n\n\n\n\n  addCurvePoint(point, color=''){\n    let curveData = this.getCurveTone(color)\n    curveData.push(point)\n    this.setCurveTone(curveData, color)\n  }\n\n\n  getCurveNumberOfPoints(color=''){\n    return this.getCurveTone(color).length\n  }\n\n\n  /**\n   * Add some duplicata curve points that will be interpolate afterwards.\n   * The index of the duplicated point is random, to be tested if it's the correct approach.\n   */\n  addCurveInterpolationPoints(numberOfPoints, color=''){\n    let curveData = this.getCurveTone(color)\n    let existingCurveData = this.getCurveTone(color)\n    let originalLength = existingCurveData.length\n\n    let pointsToAdd = numberOfPoints\n    while(pointsToAdd){\n      existingCurveData.push(existingCurveData[~~(Math.random() * originalLength)].slice())\n      pointsToAdd --\n    }\n    this.setCurveTone(existingCurveData, color)\n  }\n\n\n  /**\n   * Remove duplicate of curve points that were added synthetically.\n   * Are considered 'duplicates' two points that have the same x value\n   * (y does not matter)\n   */\n  sanitizeCurve(color=''){\n    let existingCurveData = this.getCurveTone(color)\n    let existingX = []\n    let newCurveData = []\n\n    existingCurveData.forEach(point => {\n      if(!existingX.includes(point[0])){\n        existingX.push(point[0])\n        newCurveData.push(point)\n      }\n    })\n    this.setCurveTone(newCurveData, color)\n  }\n\n\n  clone(){\n    let clone = new AdobeMetadata()\n    clone.setXmlPayload(this._xmlPayload)\n    return clone\n  }\n\n}\n\nexport default AdobeMetadata\n","import AdobeMetadata from './AdobeMetadata'\nimport { MonotonicCubicSpline } from 'splines'\n\n\nclass AdobeMetadataInterpolator {\n\n  static findNumberSequence(filename){\n    let splitChar = ' '\n    let numbersOnly = Array.from(filename).map(char => isNaN(parseInt(char)) ? splitChar : char)\n      .join('')\n      .split(splitChar)\n      .filter(substr => substr !== '')\n      .map(substr => parseInt(substr))\n      .filter(substr => substr !== NaN)\n\n    if(numbersOnly.length){\n      let number = numbersOnly[0]\n      let numberPosition = filename.indexOf(number)\n      let prefix = filename.slice(0, numberPosition)\n      let suffix = filename.slice(numberPosition + number.toString().length )\n      return {\n        number: number,\n        prefix: prefix,\n        suffix: suffix\n      }\n    }else{\n      return null\n    }\n  }\n\n  constructor(){\n    this._controlPoints = {}\n    this._collection = {}\n  }\n\n\n  addControlPoint(filename, xmlPayload){\n    let sequenceInfo = AdobeMetadataInterpolator.findNumberSequence(filename)\n    if(!sequenceInfo){\n      throw new Error(`The filename must contain a sequence of number in its name. (\"${filename}\" given)`)\n    }\n\n    let adobeMetadata = new AdobeMetadata()\n    adobeMetadata.setXmlPayload(xmlPayload)\n\n    this._controlPoints[sequenceInfo.number] = {\n      filename: filename,\n      adobeMetadata: adobeMetadata,\n      ...sequenceInfo\n    }\n\n    console.log(adobeMetadata)\n\n    // resetting the collection\n    this._collection = {}\n  }\n\n\n  checkControlPointIntegrity(){\n    let controlPointList = Object.values(this._controlPoints)\n\n    // there must be at least two control point in order to interpolate in betwen\n    if(controlPointList.length < 2){\n      throw new Error(`There must be at least two control points, only ${controlPointList.length} given.`)\n    }\n\n    // they must all have the same prefix\n    let allSamePrefix = controlPointList.map(cp => cp.prefix).every(prefix => prefix === controlPointList[0].prefix)\n    if(!allSamePrefix){\n      throw new Error('All the control point filename must have the same shape: prefix, sequence number, suffix. Prefixes differ.')\n    }\n\n    // they must all have the same suffix\n    let allSameSuffix = controlPointList.map(cp => cp.suffix).every(suffix => suffix === controlPointList[0].suffix)\n    if(!allSameSuffix){\n      throw new Error('All the control point filename must have the same shape: prefix, sequence number, suffix. Suffixes differ.')\n    }\n\n    // check if all the provided meta are actually the result of development\n    let allHaveSettings = controlPointList.map(cp => cp.adobeMetadata).every(adobeMetadata => adobeMetadata.hasSettings())\n    if(!allHaveSettings){\n      throw new Error('All the provided XMP file must be the result of photo development (not blank).')\n    }\n\n    return true\n  }\n\n\n  interpolate(){\n    // order the control points\n    let controlPointList = Object.values(this._controlPoints)\n      .sort((a, b) => a.number < b.number ? -1 : 1)\n\n    let firstControlPoint = controlPointList[0]\n    let firstIndex = firstControlPoint.number\n    let lastIndex = controlPointList[controlPointList.length - 1].number\n    let prefix = firstControlPoint.prefix\n    let suffix = firstControlPoint.suffix\n\n    // check is any of these has the cropping enable, if so, enable for all\n    // so that we can interpolate the crop just like any other params\n    let someHasCrop = controlPointList.map(cp => cp.adobeMetadata).some(meta => meta.hasCrop())\n    if(someHasCrop){\n      controlPointList.map(cp => cp.adobeMetadata).forEach(meta => meta.enableCropping())\n    }\n\n    // create clones of the first AdobeMetadata objects for all the series\n    let intermediates = []\n    for(let i=firstIndex; i<=lastIndex; i++){\n      if(i in this._controlPoints){\n        intermediates.push(this._controlPoints[i]) // replacing an intermediate by a control point\n      }else{\n        let clone = firstControlPoint.adobeMetadata.clone()\n        clone.setRawFileName(`${prefix}${i}${suffix}`)\n        intermediates.push({\n          adobeMetadata: clone,\n          number: i\n        })\n      }\n    }\n\n    // get the list of setting attributes\n    let settingAttributeNames = firstControlPoint.adobeMetadata.getListOfSettingAttributes()\n\n    // for each setting attribute, we build a spline that goes along all the control points\n    let xs = controlPointList.map(cp => cp.number)\n\n    // for each settings, we create the y coordinates to interpolate on\n    settingAttributeNames.forEach(attr => {\n      let ys = controlPointList.map(cp => cp.adobeMetadata.getSettingAttribute(attr))\n      let splineInterpolator = new MonotonicCubicSpline(xs, ys)\n\n      // for each intermediate, we interpolate\n      intermediates.forEach(inter => {\n        // control points don't need interpolation\n        if(inter.number in this._controlPoints){\n          return\n        }\n\n        inter.adobeMetadata.setSettingAttribute(attr, splineInterpolator.interpolate(inter.number))\n      })\n    })\n\n\n    // curve interpolation\n    function interpolateCurve(color=''){\n      // get the curve that has the largest amount of point among all the control points\n      let maxNbPoint = 0\n      controlPointList.forEach(cp => {\n        let nbPoints = cp.adobeMetadata.getCurveNumberOfPoints()\n        maxNbPoint = Math.max(maxNbPoint, nbPoints)\n      })\n\n      // add fake points to all the control point curve, so that all curves from\n      // a given color have the same number of points n each control point\n      controlPointList.forEach(cp => {\n        let nbPoints = cp.adobeMetadata.getCurveNumberOfPoints()\n        if(nbPoints < maxNbPoint){\n          cp.adobeMetadata.addCurveInterpolationPoints(maxNbPoint - nbPoints, color)\n        }\n      })\n\n      // for each point of the curve, we interpolate\n      for(let i=0; i<maxNbPoint; i++){\n        let allTheiPoints = controlPointList.map(cp => cp.adobeMetadata.getCurveTone(color)[i])\n        let xs = allTheiPoints.map(iPoint => iPoint[0])\n        let ys = allTheiPoints.map(iPoint => iPoint[1])\n\n      }\n\n\n    }\n\n    interpolateCurve()\n\n\n\n\n    // building the collection\n    intermediates.forEach(inter => {\n      this._collection[`${prefix}${inter.number}${suffix}`] = inter.adobeMetadata\n    })\n\n    return this._collection\n  }\n\n\n  getCollection(){\n    return this._collection\n  }\n\n}\n\nexport default AdobeMetadataInterpolator\n","import AdobeMetadata from './AdobeMetadata'\nimport AdobeMetadataInterpolator from './AdobeMetadataInterpolator'\n\nexport default { AdobeMetadata, AdobeMetadataInterpolator }\n"],"names":[],"mappings":"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"}